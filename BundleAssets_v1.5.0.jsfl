/*v1.5.0Added support for external ANT compilev1.4Ability to import png or jpg into bundles- Any bundle folder can contain FLA or PNG/JPG- Imported images get "allowSmoothing" enabled during import- .4- fix for prioritized bundle names- .5- addition of audio bundlingv1.3Addition of date checking and bundle deletion.- Bundles which have not been altered since the last date will not be recompiled.- Bundle SWFs which no longer have a corresponding bundle folder are deleted- Improvements to XML output including formatting, type attributes, and compilation date/time stampSearch through the source folder. For each folder found, create a new "bundle" FLA file of the same name.Within each folder, find each supported file.Open the FLA file and retrieve the symbol of the same name. Example: GFX_SomeFile.fla will contain a symbol called "GFX_SomeFile", and it will contain a linkage "GFX_SomeFile"Import the symbol into the bundle FLA into a folder named after the symbol. Example: GFX_SomeFile_folder folder will contain GFX_SomeFile symbol.Publish the bundle as a swf.Generate an XML defining the bundles and symbols within each bundle.When building with the ANT task, the "@@" data will be replaced with proper paths and settings. If not running with ANT, the execute will ask the user to manually select source and destination.*/// PROPERTIESvar xmlSaveName = "assetsManifest.xml";var errorSaveName = "errors.txt";//var deleteBundleFlaOnCompletion = true; // Indicate whether to delete the generated FLA files on completion. The FLA files are not necessary but are helpful for debugging bundling issues.var supportedFileTypes = ["fla", "png", "jpg", "jpeg", "mp3"]; // The file extensions supported by import// REPLACEMENT PROPERTIES// Source of assets to bundle. Note that the @ srcpath @ is designed to be replaced by ANT. No need to manually change. If the value is not altered, you will get a "Select source" dialogvar sourceAssetsURI = "@srcpath@";// Destination of outputvar outputURI = "@destpath@";// Delete bundle FLAs when completevar deleteBundleFLAs = "@deletebundles@";// XML save pathvar xmlSavePath;var errorSavePath;// Execute the functionexecute();function execute() {    // SOURCE    if (sourceAssetsURI == ("@" + "srcpath" + "@")) {        // If not run from ANT, ask the user to select a source folder        sourceAssetsURI = fl.browseForFolderURL("Select source folder.");    }    if (sourceAssetsURI == null) {        // Still missing a definition        fl.trace("Missing source folder");        return;    }    // OUTPUT    if (outputURI == ("@" + "destpath" + "@")) {        // If not run from ANT, ask the user to select a destination folder        outputURI = fl.browseForFolderURL("Select output folder.");    }    if (outputURI == null) {        // Still missing a definition        fl.trace("Missing output folder");        return;    }    // Build paths    xmlSavePath = outputURI + "/" + xmlSaveName;    errorSavePath = outputURI + errorSaveName;        // Default to not deleting bundles    if (deleteBundleFLAs == ("@" + "deletebundles" + "@")) {        deleteBundleFLAs = confirm("Delete generated FLA files on completion? OK=delete, Cancel=retain for debugging"); //deleteBundleFlaOnCompletion;    }	// Convert to boolean	if (deleteBundleFLAs=="true"){		deleteBundleFLAs = true;	}	    // Clear compiler errors    fl.compilerErrors.clear();    /*    var response = prompt("What is your name?");    if (response == null || response.length == 0) {    alert("FINE!");    } else {    alert("You said: " + response);    }    */    // Add trailing slashes;    if (sourceAssetsURI.charAt(sourceAssetsURI.length - 1) != "/") {        sourceAssetsURI += "/";    }    if (outputURI.charAt(outputURI.length - 1) != "/") {        outputURI += "/";    }    // Clean the output folder of any swfs which are orphaned. Return a list of bundles which need to be built/refreshed    var buildList = generateBuildList();    // Check for no changes    if (buildList.length == 0) {        fl.trace("no changes compiled");        finish();        return;    }    // Bundle all of the assets, generate the library and element nodes of the XML    var bundleXML = bundleFiles(buildList);    // Generate an XML document to capture the bundling    // <info> node used for extra data    var infoData = "\t<info>\n\t\t<compiledate>" + new Date() + "</compiledate>\n\t</info>\n";    var xmlDoc = "<data>\n" + infoData + bundleXML + "\n</data>";    // Save the XML    saveXML(xmlDoc);	finish();}function generateBuildList() {    //FLfile.remove(outputURI);    //FLfile.createFolder(outputURI);    //FLfile.setAttributes(outputURI, "W");    // Determine which bundles have new content by comparing the date of the bundle folder with that of the SWF    // If the bundle is newer, or no SWF exists, this needs to be bundled    // If a swf exists with no bundle, it is removed    var buildList = [];    var bundleName;    var bundleFolder;    var bundleFolderDate;    var bundleSwfName;    var bundleSwfFile;    var bundleSwfDate;    var filterURI;    var fileList;    var listFileName;    var fileRef;    var fileDate;    // List of bundle names (from sub directories)    bundleList = FLfile.listFolder(sourceAssetsURI, "directories");    if (bundleList) {        for (bundleInd = 0; bundleInd < bundleList.length; bundleInd++) {            // Name of each bundle (folder)            bundleName = bundleList[bundleInd];                        // Bundle folder path            bundleFolder = sourceAssetsURI + bundleName + "/";                        // Date of bundle folder as Javascript Date Object            bundleFolderDate = FLfile.getModificationDate(bundleFolder);                        // Check for matching SWF            bundleSwfName = (bundleName + ".swf");            bundleSwfFile = (outputURI + bundleSwfName);            if (FLfile.exists(bundleSwfFile)) {                // If the file exists, check the date                bundleSwfDate = FLfile.getModificationDate(bundleSwfFile);                if (bundleFolderDate > bundleSwfDate) {                    // Bundle folder has been updated more recently than SWF                    // Add this to the build list                    buildList.push(bundleName);                } else {                    // Check for individual file modification dates in bundle folder                    fileList = getAllFiles(bundleFolder);                    for (var fileInd = 0; fileInd < fileList.length; fileInd++) {                        listFileName = fileList[fileInd];                        fileRef = bundleFolder + listFileName;                        fileDate = FLfile.getModificationDate(fileRef);                        if (fileDate > bundleSwfDate) {                            // Bundle folder has been updated more recently than SWF                            buildList.push(bundleName);                            break;                        }                    }                }            } else {                // SWF doesn't exist, add it to the buildList                buildList.push(bundleName);            }        }    }    //// DELETION ////    // Delete any SWFs for bundles which have been deleted    filterURI = outputURI + "*.swf";    swfList = FLfile.listFolder(filterURI, "files");    if (swfList && (swfList.length > 0)) {        for (swfInd = 0; swfInd < swfList.length; swfInd++) {            swfName = swfList[swfInd];            var nameSplit = swfName.split(".");            var fileBundleName = nameSplit.slice(0, (nameSplit.length - 1));            var flaName = fileBundleName + ".fla";            var bundleInd = buildList.indexOf(fileBundleName);            if (!FLfile.exists(sourceAssetsURI + fileBundleName)) {                // This bundle folder no longer exists                FLfile.remove(outputURI + swfName);                FLfile.remove(outputURI + flaName);                // Remove bundle from buildList                if (bundleInd > -1) {                    buildList.splice(bundleInd, 1);                }            } else {                // If the bundle folder exists, check if it contains any of the supported file types                fileList = getAllFiles(sourceAssetsURI + fileBundleName + "/");                if (!fileList || (fileList.length == 0)) {                    // This bundle no longer exists                    FLfile.remove(outputURI + swfName);                    FLfile.remove(outputURI + flaName);                    // Remove bundle from buildList                    if (bundleInd > -1) {                        buildList.splice(bundleInd, 1);                    }                }            }        }    }    return buildList;}function bundleFiles(buildList) {    var xmlDoc = "";    // List of bundle names (from sub directories)    var bundleList = FLfile.listFolder(sourceAssetsURI, "directories");    if (bundleList) {        for (bundleInd = 0; bundleInd < bundleList.length; bundleInd++) {            // Name of each bundle (folder)            var bundleName = bundleList[bundleInd];            // Final name of bundle (after removing priority tag)            var finalBundleName = bundleName;            // Bundle folder path            var bundleFolder = sourceAssetsURI + bundleName + "/";            // Name/path of bundle FLA            var bundleFlaName = bundleName + ".fla";            var bundleSavePath = outputURI + bundleFlaName;            // List of supported files in each bundle folder            var fileList = getAllFiles(bundleFolder);            var fileCount = fileList.length;            if (fileList && (fileCount > 0)) {                // Only create if the bundle contains supported files                // Set load priority by using suffix on the bundle folder. _1 = preload, _2 = postload, _3 = ondemand. Example: GUIBundle_1.fla would be a load="true"                var bundleNameArray = bundleName.split("_");                var loadPriority = 1;                if (bundleNameArray.length > 1) {                    finalBundleName = bundleNameArray.slice(0, (bundleNameArray.length - 1)).join("_");                    var suffix = bundleNameArray[(bundleNameArray.length - 1)];                    switch (suffix) {                        case "1":                            loadPriority = 1;                            break;                        case "2":                            loadPriority = 2;                            break;                        case "3":                            loadPriority = 3;                            break;                    }                }                // Determine if this bundle is being built, based on input buildList                var buildThisBundle = (buildList.indexOf(bundleName) > -1);                // Generate the LoaderMax loaders                xmlDoc += "\n\t<!-- START \"" + finalBundleName + "\" bundle -->";                // Generate SWFLoader. Use load priority to manage load handling.                xmlDoc += "\n\t<SWFLoader url=\"" + (finalBundleName + ".swf") + "\" name=\"" + (finalBundleName) + "\" load=\"";                if (loadPriority == 1) {                    xmlDoc += "true";                } else {                    xmlDoc += "false";                }                xmlDoc += "\" postLoad=\"";                if (loadPriority == 2) {                    xmlDoc += "true";                } else {                    xmlDoc += "false";                }                xmlDoc += "\" />";                // Append bundle node to XML                xmlDoc += "\n\t<library bundle=\"" + finalBundleName + "\" >";                // Create a new bundle FLA, if required                var bundleDoc;                var bundleLib;                var bundleFolderNames;                if (buildThisBundle) {                    fl.createDocument();                    bundleDoc = fl.getDocumentDOM();                    // Library of new bundle doc                    bundleLib = bundleDoc.library;                    // Array of folders in this bundle                    bundleFolderNames = [];                }                // Load each file in the bundle;                for (var fileInd = 0; fileInd < fileCount; fileInd++) {                    // Name of the loaded file                    var listFileName = fileList[fileInd];                    var listFileSplit = listFileName.split(".");                    // Generate symbol name from file name                    var symbolName = listFileSplit[0];                    var listFileExtension = listFileSplit[listFileSplit.length - 1];                    // Name of folder to create in bundle library to store each symbol & support symbols                    var bundleFolderName = symbolName + "_folder";                    // Generate the "type" property from the filename. Example: GFX_SomeFile.fla will have a type of "GFX";                    var assetTypeArray = symbolName.split("_");                    var assetType = "";                    if (assetTypeArray.length > 0) {                        assetType = assetTypeArray[0];                    }                    // Track whether addition was successful                    var symbolAdded = false;                    // Don't import assets when this bundle is not being generated                    if (buildThisBundle == false) {                        // Flag to add to XML                        symbolAdded = true;                    } else {                        // Create a folder in the bundle library for each fla/symbol within the bundle folder                        // Add to array of bundle folders                        bundleFolderNames.push(bundleFolderName);                        if (bundleLib.addNewItem("folder", bundleFolderName)) {                            // Open the source file                            var listFilePath = bundleFolder + listFileName;                            var sourceFlaDoc;                            var copiedToClipboard = false;                            var imported;                            if (listFileExtension == "fla") {                                // FLA files open the source FLA                                sourceFlaDoc = fl.openDocument(listFilePath);                            } else if (listFileExtension == "mp3") {                                // MP3 are imported right into the bundle lib                                sourceFlaDoc = null;                                imported = bundleDoc.importFile(listFilePath, false);                                if (imported) {                                    bundleLib.selectNone();                                    if (bundleLib.selectItem(listFileName)) {                                        // Set sound settings                                        var snd = bundleLib.getSelectedItems()[0];                                        snd.name = symbolName;                                        snd.linkageExportForAS = true;                                        snd.linkageExportInFirstFrame = true;                                        snd.linkageIdentifier = symbolName;                                        //bundleLib.renameItem(symbolName);                                        bundleLib.moveToFolder(bundleFolderName, symbolName, true);                                        // Flag to add to XML                                        symbolAdded = true;                                    }                                } else {                                    // File didn't import                                    fl.trace("file didn't import");                                    continue;                                }                            } else {                                // PNG/JPG will create a temp source FLA to import/convert symbols                                sourceFlaDoc = fl.createDocument();                                imported = sourceFlaDoc.importFile(listFilePath, false);                                if (imported) {                                    if (sourceFlaDoc.selection.length == 1) {                                        // Bitmap settings                                        var bmp = sourceFlaDoc.selection[0].libraryItem;                                        bmp.allowSmoothing = true;                                        // Convert to a MovieClip                                        var newMC = sourceFlaDoc.convertToSymbol("movie clip", symbolName, "top left");                                        // Set linkage data, including changing to a Sprite                                        newMC.linkageExportForAS = true;                                        newMC.linkageExportInFirstFrame = true;                                        newMC.linkageIdentifier = symbolName;                                        newMC.linkageBaseClass = "flash.display.Sprite";                                        // Copy to clipBoard;                                        sourceFlaDoc.clipCopy();                                        copiedToClipboard = true;                                    } else {                                        // More or less than one thing selected on stage (probably can't happen)                                        fl.trace("selection mismatch");                                        continue;                                    }                                } else {                                    // File didn't import                                    fl.trace("file didn't import");                                    continue;                                }                            }                            // Add the symbol into the bundle                            if (sourceFlaDoc) {                                // The library of the opened source FLA                                var sourceFlaLib = sourceFlaDoc.library;                                if (listFileExtension == "fla") {                                    // For FLA source, instantiate the item from the library to the stage to copy it. Image imports have already copied to clipboard                                    // Get the symbol from the source FLA                                    if (sourceFlaLib.selectItem(symbolName)) {                                        // Add the symbol to the source FLA's stage (needed for copying)                                        sourceFlaLib.addItemToDocument({x: 0, y: 0});                                        // Copy to clipBoard;                                        sourceFlaDoc.clipCopy();                                        copiedToClipboard = true;                                    }                                }                                if (copiedToClipboard) {                                    // Paste it into the bundle FLA's stage;                                    bundleDoc.clipPaste();                                    // Flag to add to XML                                    symbolAdded = true;                                    // Rename all of the newly added assets to ensure no naming conflicts with sub-items                                    // Receive a list of all newly added assets                                    var addedFiles = renameAddedFiles(bundleFolderNames, bundleLib, symbolName);                                    // Move the items into the bundle folder. Loop through the items in the library                                    // For each added item                                    for (libInd = 0; libInd < addedFiles.length; libInd++) {                                        //                                         var addedItem = addedFiles[libInd];                                        // Move it if it is not the bundleFolder and it is a root-level item (items which are not root level will be moved when their parent is moved. Example: assets/somefile)                                        if ((addedItem.name != bundleFolderName) && (addedItem.name.split("/").length == 1)) {                                            // Move this into the bundle folder                                            bundleLib.moveToFolder(bundleFolderName, addedItem.name, true);                                        }                                    }                                    // Remove the item from the stage of the bundle                                    bundleDoc.deleteSelection();                                }                                // Close the source FLA without prompting to save changes                                fl.closeDocument(sourceFlaDoc, false);                            }                        }                    }                    // Add the XML if the symbol was added                    if (symbolAdded) {                        // Append the element to the XML                        xmlDoc += "\n\t\t<element id=\"" + symbolName + "\" classname=\"" + symbolName + "\" type=\"" + assetType + "\" />";                    }                }                if (buildThisBundle == true) {                    // Change the publish settings to export just the .swf, and to set correct file path                    publishSettingsSwfOnly(bundleDoc, finalBundleName);                    // Save/replace the bundle FLA                    fl.saveDocument(bundleDoc, bundleSavePath);                    // Publish swf of bundle FLA                    bundleDoc.publish();                    // Close the bundle FLA;                    fl.closeDocument(bundleDoc, false);                    // Delete the bundle FLA file                    if (deleteBundleFLAs == true) {                        FLfile.remove(outputURI + bundleFlaName);                    }                }                // Close bundle node in XML;                xmlDoc += "\n\t</library>";                xmlDoc += "\n\t<!-- END \"" + finalBundleName + "\" bundle -->\n";            } else {                // No files in this bundle            }        }    }    return xmlDoc;}function publishSettingsSwfOnly(bundleDoc, bundleName) {    // Change the publish settings to export just the .swf, and to set correct file path    var profileXML = bundleDoc.exportPublishProfileString('Default');    // remove html publishing and default naming    profileXML = profileXML.replace("<html>1</html>", "<html>0</html>");    profileXML = profileXML.replace("<defaultNames>1</defaultNames>", "<defaultNames>0</defaultNames>");    profileXML = profileXML.replace("<flashDefaultName>1</flashDefaultName>", "<flashDefaultName>0</flashDefaultName>");    var findString = "<flashFileName>";    var startIndex = profileXML.indexOf(findString) + findString.length;    findString = "</flashFileName>";    var endIndex = profileXML.indexOf(findString);    var curName = profileXML.substring(startIndex, endIndex);    var pubPath = bundleName;    profileXML = profileXML.replace(curName, pubPath);    bundleDoc.importPublishProfileString(profileXML);}function renameAddedFiles(bundleFolderNames, bundleLib, symbolName) {    // Rename all newly created items    // Return the files that were renamed (those which are added in this round)    // Array of files added in this paste    var addedFiles = [];    // For each item in the lib    for (libInd = 0; libInd < bundleLib.items.length; libInd++) {        // Get the item        var libItem = bundleLib.items[libInd];        // If this item is not already in any bundle folder        if (isInBundleFolder(libItem, bundleFolderNames) == false) {            // It was newly added in this paste            addedFiles.push(libItem);            // Rename the item if its name (not including its file path) does not contain the symbolName;            var nameSplit = libItem.name.split("/");            var itemName = (nameSplit[(nameSplit.length - 1)]);            if (itemName.indexOf(symbolName) == -1) {                libItem.name = itemName + "_" + symbolName;            }        }    }    return addedFiles;}function isInBundleFolder(libItem, bundleFolderNames) {    // Check if an item is in any bundleFolders    for (folderInd = 0; folderInd < bundleFolderNames.length; folderInd++) {        if (libItem.name.indexOf(bundleFolderNames[folderInd]) > -1) {            return true;        }    }    return false;}function saveXML(xmlDoc) {    FLfile.write(xmlSavePath, xmlDoc);}function getAllFiles(curFolder) {    // Return a list of all files of the supported types    var fileList = [];    var fileTypeCount = supportedFileTypes.length;    var filterURI;    for (var ind = 0; ind < fileTypeCount; ind++) {        var fileType = supportedFileTypes[ind];        filterURI = curFolder + "*." + fileType;        var checkFileList = FLfile.listFolder(filterURI, "files");        if (checkFileList && (checkFileList.length > 0)) {            fileList = fileList.concat(checkFileList);        }    }    return fileList;}function finish() {	fl.compilerErrors.save(errorSavePath);}